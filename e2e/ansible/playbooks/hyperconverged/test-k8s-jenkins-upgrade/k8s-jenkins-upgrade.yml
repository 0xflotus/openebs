#k8s-jenkins-upgrade.yml
# Description: Deploy Jenkins application using OpenEBS volume.
# Created jobs and builds inside mounted path and role upgrade pods.
# Check for jobs and build after Upgrade.

###############################################################################################
#Test Steps:
#1. Check whether the OpenEBS components are deployed.
#2. Download the test artifacts to k8s master.
#3. Deploy Jenkins application.
#4. Check if the application pod is up and running
#5. Check if the Jenkins service us up.
#6. Perform Job creation and building activity inside pod.
#7. Check for data persitency.
###############################################################################################

- hosts: localhost

  vars_files:
    - k8s-jenkins-pod-vars.yml
 
  tasks:

   - block:

     - include: k8s-jenkins-pod-prereq.yml
      
     - name: Download YAML for jenkins 
       include_tasks: "{{ansible_env.HOME}}/{{utils_path}}/get_url.yml"
       vars:
         url: "{{ jenkins_link }}"
         dest: "{{ result_kube_home.stdout }}/{{ pod_yaml_alias }}"

     - name: Check whether maya-apiserver is deployed
       include_tasks: "{{ansible_env.HOME}}/{{utils_path}}/deploy_check.yml"
       vars:
          ns: "{{ operator_ns }}"
          app: maya-api

     - name: Replace jenkins pod version
       lineinfile:
         path: "{{ result_kube_home.stdout }}/{{ pod_yaml_alias }}"
         regexp: "image: jenkins/jenkins:"
         line: "     image: jenkins/jenkins:{{jenkinsold}}"
       delegate_to: "{{groups['kubernetes-kubemasters'].0}}"

    
     - name: Create namespace for deployement.
       shell: source ~/.profile; kubectl create ns {{namespace}}
       args:
         executable: /bin/bash
       delegate_to: "{{groups['kubernetes-kubemasters'].0}}"

      
     - name:  Deploy jenkins pod 
       include_tasks: "{{ansible_env.HOME}}/{{utils_path}}/deploy_task.yml"
       vars:
          app_yml: "{{ pod_yaml_alias }}"
          ns: "{{ namespace }}"
    
     - name:  Confirm pod status is running
       include_tasks: "{{ansible_env.HOME}}/{{utils_path}}/deploy_check.yml"
       vars:
          ns: "{{ namespace }}"
          app: jenkins

     - name: Verify that the jenkins is a cluster service
       shell: source ~/.profile; kubectl get svc -n {{namespace}}
       args:
         executable: /bin/bash
       delegate_to: "{{groups['kubernetes-kubemasters'].0}}"
       register: result_service
       failed_when: "'jenkins-svc' not in result_service.stdout"

     - name: Get the name of the pod.
       shell: source ~/.profile; kubectl get pods -n {{namespace}} | grep jenkins | awk {'print $1'}
       args: 
         executable: /bin/bash
       delegate_to: "{{groups['kubernetes-kubemasters'].0}}"
       register: jenkins_pod_name

         
     - name: Download Jenkins-cli.jar file inside /var/jenkins_home of pod.
       shell: >
          source ~/.profile; kubectl exec {{ jenkins_pod_name.stdout }} -n {{ namespace }} 
          -- wget -P /var/jenkins_home http://localhost:8080/jnlpJars/jenkins-cli.jar
       args:
         executable: /bin/bash
       delegate_to: "{{groups['kubernetes-kubemasters'].0}}"
       untill: "'saved' in  result.stdout"
       delay: 80
       retries: 8

     - name: Copy job configuration files to master.
       include_tasks: "{{ansible_env.HOME}}/{{utils_path}}/copy_task.yml"
       vars:
         destination_node: "{{groups['kubernetes-kubemasters'].0}}"
         files_to_copy: "{{ job_config_files }}"

     - name: Copy job configuration files to jenkins-pod from master.
       shell: |
         source ~/.profile; kubectl cp template.xml  {{namespace}}/{{ jenkins_pod_name.stdout }}:/var/jenkins_home/
         source ~/.profile; kubectl cp config_change.sh {{namespace}}/{{ jenkins_pod_name.stdout }}:/var/jenkins_home/
       args:
         executable: /bin/bash
       delegate_to: "{{groups['kubernetes-kubemasters'].0}}" 
   
     - name: Run the config_change.sh file for required changes inside pod.
       shell: > 
          source ~/.profile; kubectl exec {{  jenkins_pod_name.stdout }} -n {{ namespace }} -- bash -c "sh /var/jenkins_home/config_change.sh"
       args:
         executable: /bin/bash
       delegate_to: "{{groups['kubernetes-kubemasters'].0}}"

     - name: Retrieve Password of jenkins running pods.
       shell: >
          source ~/.profile; kubectl exec  {{ jenkins_pod_name.stdout }} -n {{ namespace }}
          -- bash -c "cat /var/jenkins_home/secrets/initialAdminPassword"
       args:
         executable: /bin/bash
       delegate_to: "{{groups['kubernetes-kubemasters'].0}}"
       register: jenkins_password
  
     - name: Restart the jenkins pod for running jenkins actions.
       shell: >
          source ~/.profile; kubectl exec {{ jenkins_pod_name.stdout }} -n {{ namespace }} 
          -- java -jar /var/jenkins_home/jenkins-cli.jar -s http://localhost:8080 restart
          --username admin --password {{ jenkins_password.stdout }}
       args:
         executable: /bin/bash
       delegate_to: "{{groups['kubernetes-kubemasters'].0}}"

     - name: wait for 20 seconds.
       wait_for:
          timeout: 20
 
     - name: Create and Build one sample job inside pod.
       shell: |
         source ~/.profile; kubectl exec {{ jenkins_pod_name.stdout }} -n {{ namespace }} -- bash -c "java -jar /var/jenkins_home/jenkins-cli.jar -s http://localhost:8080 create-job sample < /var/jenkins_home/template.xml"
         source ~/.profile; kubectl exec {{ jenkins_pod_name.stdout }} -n {{ namespace  }} -- bash -c "java -jar /var/jenkins_home/jenkins-cli.jar -s http://localhost:8080 build sample" 
       args:
         executable: /bin/bash
       delegate_to: "{{groups['kubernetes-kubemasters'].0}}"
    
     - name: Running a build job
       shell: >
          source ~/.profile; kubectl exec {{ jenkins_pod_name.stdout }} -n {{ namespace }}
          -- bash -c "java -jar /var/jenkins_home/jenkins-cli.jar -s http://localhost:8080 console sample"
       arge:
         executable: /bin/bash
       delegate_to: "{{groups['kubernetes-kubemasters'].0}}" 
       register: First_Build
  
     - name: (2) Replace jenkins pod version 
       lineinfile:
         path: "{{ result_kube_home.stdout }}/{{ pod_yaml_alias }}"
         regexp: "image: jenkins/jenkins:"
         line: "     image: jenkins/jenkins:{{jenkinsnew}}"
       delegate_to: "{{groups['kubernetes-kubemasters'].0}}"

     - name: (2) Deploy jenkins pod Again
       include_tasks: "{{ansible_env.HOME}}/{{utils_path}}/deploy_task.yml"
       vars:
          app_yml: "{{ pod_yaml_alias }}"
          ns: "{{ namespace }}"

     - name: (2) Confirm pod status is running
       include_tasks: "{{ansible_env.HOME}}/{{utils_path}}/deploy_check.yml"
       vars:
          ns: "{{namespace}}"
          app: jenkins

     - name: (2) Verify that the jenkins is a cluster service
       shell: source ~/.profile; kubectl get svc
       args:
         executable: /bin/bash
       delegate_to: "{{groups['kubernetes-kubemasters'].0}}"
       register: result_service_2
       failed_when: "'jenkins-svc' not in result_service.stdout"

     - name: (2) Get the name of the pod.
       shell: source ~/.profile; kubectl get pods -n {{ namespace }} | grep jenkins | awk {'print $1'}
       args:
         executable: /bin/bash
       delegate_to: "{{groups['kubernetes-kubemasters'].0}}"
       register: jenkins_pod_name_2

     - name: Create a new build from existing  job inside pod.
       shell: > 
          source ~/.profie; kubectl exec  {{ jenkins_pod_name_2.stdout }} -n {{ namespace }} 
          -- bash -c "java -jar /var/jenkins_home/jenkins-cli.jar -s http://localhost:8080 console sample"
       args:
         executable: /bin/bash
       delegate_to: "{{groups['kubernetes-kubemasters'].0}}"
       register: Second_Build
 
     - name: Compare
       set_fact:
         flag: "Test Passed"
       when: "First_Build.stdout == Second_Build.stdout"
    
     rescue:
       - name: Test Failed
         set_fact:
           flag: "Test Failed"

     always:
       - block:

           - include: k8s-jenkins-pod-upgrade-cleanup.yml

           - name: Test Cleanup Passed
             set_fact:
               cflag: "Cleanup Passed"

         rescue:
           - name: Test Cleanup Failed
             set_fact:
               cflag: "Cleanup Failed"

         always:

           - include_tasks: "{{ansible_env.HOME}}/{{utils_path}}/stern_task.yml"
             vars:
               status: stop

           - name: Send slack notification
             slack:
               token: "{{ lookup('env','SLACK_TOKEN') }}"
               msg: '{{ ansible_date_time.time }} TEST: {{test_name}}, RESULT: {{ flag }},{{ cflag }}'
             when: slack_notify | bool and lookup('env','SLACK_TOKEN')
 
